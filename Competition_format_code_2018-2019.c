#pragma config(Sensor, in1,    Gyroscope,      sensorGyro)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorRotation)
#pragma config(Sensor, dgtl2,  RightEncoder,   sensorRotation)
#pragma config(Motor,  port1,           Hasew,         tmotorNone, openLoop)
#pragma config(Motor,  port2,           BillandBob,    tmotorNone, openLoop)
#pragma config(Motor,  port3,           FredandJoseph, tmotorNone, openLoop)
#pragma config(Motor,  port4,           Pablo,         tmotorNone, openLoop)
#pragma config(Motor,  port5,           Raaj,          tmotorNone, openLoop)
#pragma config(Motor,  port6,           Adolph,        tmotorNone, openLoop)
#pragma config(Motor,  port7,           Ivan,          tmotorNone, openLoop)
#pragma config(Motor,  port10,          Schmeckle,     tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
void pre_auton()
{
  bStopTasksBetweenModes = true;
}
#define abs(X) ((X < 0) ? -1 * X : X)
//Lets the absolute value function work
void turnAmount (int degreeInTens)
/*
Allows for the degree # when you call the function
to look like an actual degree amount, as opposed to
a 4 digit number
*/
{
	int degreeInOnes = (degreeInTens * 10);
	while(abs(SensorValue[Gyroscope]) < degreeInOnes)
	/*
	while loop allows for the gyroscope to turn a specific amount,
	as specified when the function is called
	*/
	{
		motor[BillandBob] = 60;
		motor[FredandJoseph] = -60;
	}
	motor[BillandBob] = 0;
	motor[FredandJoseph] = 0;
}
void driveSquare (int distance, int power)
/* this sets it so that when the function is called
there is a set of parentheses with the #of squares
that will be traveled and the speed in which they
will be traversed*/
{
	SensorValue [LeftEncoder] = 0;
	int goalDistance = (28 * distance * 25);
	/*sets the distance traveled to our constant, which is 28,
	times the amount of squares needed, which one is 25, then
	multiplies the entire thing by the amount of squares needed,
	*/
  while(abs(SensorValue[LeftEncoder] < goalDistance))
  {
  	motor[BillandBob] = power;
  	motor[FredandJoseph] = power;
  }
  motor[BillandBob] = 0;
  motor[FredandJoseph] = 0;
  /*
  While loop allows for you to only move specified amount in the
  "coordinates" given when you call the function
  */
}
task autonomous()
{
	turnAmount(90);
	/*
	First time this function is called, it makes the bot turn 90
	degrees exactly
	*/
  driveSquare(1,60);
  /*
  First time calling the function, it is to make the robot move
  1 square at 60 motor power.
  */
  turnAmount(270);
  driveSquare(3,60);

}
task usercontrol()
{
	 while (true)
  {
    while(1 == 1)
			{
				//Movement System
				motor[BillandBob]= vexRT[Ch3];
				motor[FredandJoseph]= vexRT[Ch2];
					//Arm System
				if(vexRT[Btn6U] == 1)
				{
					motor[Hasew] = 127;
					motor[Schmeckle] = -127;
				}
					else if(vexRT[Btn6D] == 1)
				{
					motor[Hasew] = -127;
					motor[Schmeckle] = 127;
				}
					else
				{
						motor[Hasew] = 0;
						motor[Schmeckle] = 0;
				}

						//Launcher System
						if(vexRT[Btn5U] == 1)
						{
							motor[Adolph] = 63;
							motor[Ivan] = 63;
						}
						else if(vexRT[Btn5D] == 1)
						{
							motor[Adolph] = -63;
							motor[Ivan] = -63;
						}
						else
						{
							motor[Adolph] = 0;
							motor[Ivan] = 0;
								//Claw System
							if(vexRT[Btn8U]==1)
							{
								motor[Raaj] = 36;
							}
							else if(vexRT[Btn8D]==1)
							{
								motor[Raaj] = -36;
							}
							else
							{
								motor[Raaj] = 0;
							}
							//ELbow system
							if(vexRT[Btn8L]==1)
							{
								motor[Pablo] = 63;
							}
							else if(vexRT[Btn8R]==1)
							{
								motor[Pablo] = -63;
							}
							else
							{
								motor[Pablo] = 0;
							}

				}
			}
		}
	}
